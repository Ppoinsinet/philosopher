#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <time.h>
#include <sys/time.h>
#include <unistd.h>

pthread_mutex_t mutex;

typedef struct		s_philo
{
	int				index;
	pthread_t		thread;
	int				time_to_die;
	int				time_to_eat;
	int				time_to_sleep;
	int				n_eat;
	long			desired;
	struct timeval 	life;
	void			*scene;
}					t_philo;

typedef struct	s_scene
{
	int			forks;
	int			num_philo;
	int			time_to_die;
	int			time_to_eat;
	int			time_to_sleep;
	int			n_eat;
	long		begin;
	t_philo		*tab;
	char		finished;
}				t_scene;

int		diffTime(t_philo *philo)
{
	struct timeval current;
	gettimeofday(&current, NULL);
	long current_time = current.tv_usec / 1000 + current.tv_sec * 1000;
	current_time -= ((t_scene *) philo->scene)->begin;
	return (current_time);
}

long 	checkTime(t_philo *philo, struct timeval *current)
{
	gettimeofday(current, NULL);
	long current_time = current->tv_usec / 1000 + current->tv_sec * 1000;
	long before_time = philo->life.tv_usec / 1000 + philo->life.tv_sec * 1000;
	if (current_time - before_time >= philo->time_to_die)
	{
		printf("%dms %d is dead\n", diffTime(philo), philo->index);
		return (-1);
	}
	return (current_time);
}

int to_eat(t_philo *philo, struct timeval *current)
{
	long diff;

	gettimeofday(current, NULL);
	diff = current->tv_sec * 1000 + current->tv_usec / 1000;
	diff -= ((t_scene *)philo->scene)->begin;
	if (((t_scene *)philo->scene)->forks <= 0)
		return (1);

	pthread_mutex_lock(&mutex);
	if (((t_scene *)philo->scene)->finished || ((t_scene *)philo->scene)->forks <= 0)
	{
		pthread_mutex_unlock(&mutex);
		return (1);
	}
	philo->desired += philo->time_to_eat;
	philo->life = *current;
	((t_scene *)(philo->scene))->forks--;
	pthread_mutex_unlock(&mutex);

	printf("%ldms %d is eating : %d\n", diff, philo->index, ((t_scene *)philo->scene)->forks);
	usleep(philo->time_to_eat * 1000);

	printf("%ldms %d is sleeping\n", diff + philo->time_to_eat, philo->index);
	pthread_mutex_lock(&mutex);
	((t_scene *)(philo->scene))->forks++;
	pthread_mutex_unlock(&mutex);
	return (0);
}

void to_sleep(t_philo *philo, struct timeval *current)
{
	long diff;
	//gettimeofday(current, NULL);
	diff = current->tv_sec * 1000 + current->tv_usec / 1000 + philo->time_to_eat
		+ philo->time_to_sleep;
	diff -= ((t_scene *)philo->scene)->begin;

	usleep(philo->time_to_sleep * 1000);
	printf("%ldms %d is thinking\n", diff, philo->index);
}

void *boucle(void *arg)
{
	t_philo *philo = (t_philo *)arg;
	struct timeval current;
	long diff;
	gettimeofday(&current, NULL);
	long begin_time = current.tv_usec / 1000 + current.tv_sec * 1000;
	while (!((t_scene *)philo->scene)->finished)
	{
		philo->desired += philo->time_to_eat;








		//if ((diff = checkTime(philo, &current)) < 0)
		//{
		//	((t_scene *)philo->scene)->finished = 1;
		//	pthread_exit(NULL);
		//}
		//diff = diff - ((t_scene *)philo->scene)->begin;
		//if (((t_scene *)(philo->scene))->forks <= 0)
		//	continue ;

		//if (!(to_eat(philo, &current)))
		//	to_sleep(philo, &current);
		//usleep(10);
	}
	((t_scene *)philo->scene)->finished = 1;
	pthread_exit(NULL);
}

int main()
{
	t_scene scene;
	scene.tab = NULL;
	int num_philo = 5;
	scene.num_philo = num_philo;
	scene.forks = num_philo / 2;
	scene.time_to_sleep = 200;
	scene.time_to_eat = 200;
	scene.time_to_die = 800;
	scene.n_eat = -1;
	scene.finished = 0;
	pthread_mutex_init(&mutex, NULL);


	if (!(scene.tab = malloc(sizeof(t_philo) * scene.num_philo)))
		return (1);
	int i = 0;
	struct timeval begin;
	gettimeofday(&begin, NULL);
	scene.begin = begin.tv_sec * 1000 + begin.tv_usec / 1000;
	while (i < num_philo)
	{
		struct timeval current;
		gettimeofday(&current, NULL);
		scene.tab[i].life = current;
		(scene.tab[i]).index = i + 1;
		scene.tab[i].time_to_die = scene.time_to_die;
		scene.tab[i].time_to_eat = scene.time_to_eat;
		scene.tab[i].time_to_sleep = scene.time_to_sleep;
		scene.tab[i].n_eat = scene.n_eat;
		scene.tab[i].desired = 0;
		scene.tab[i].scene = &scene;
		i++;
	}
	for (int j = 0; j < scene.num_philo; j++)
	{
		pthread_create(&scene.tab[j].thread, NULL, boucle, &scene.tab[j]);
	}
	while (1)
	{
		usleep(10);
		if (scene.finished)
		{
			usleep(2000);
			return (1);
		}
	}
	//for (int k = 0; k < scene.num_philo; k++)
	//{
	//	pthread_join(scene.tab[k].thread, NULL);
	//	return (0);
	//}
}
